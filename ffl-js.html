<head><meta name="viewport" content="width=device-width, initial-scale=1.0"></head>
<body>
  <!-- layout -->
  <div id="top-content">
    <h3>ffl.js (real)</h3>
    <form id="charform">
      <label for="charinfo">CharInfo Base64 Data:</label>
      <input type="text" id="charinfo" value="AAAAAAkAAAAAAAAAAAAAAAAAAABlAAAARAAAgAAAAAAhAAAASQAAgAcAAAADAAAABAAAAAIAAAAQAAAAEgAAAEEAAIAIAAAAAwAAAAMAAAAMAAAABAAAAAAAAAAAAAAACwAAABcAAAATAACAAAAAAAMAAAANAAAAAAAAAAAAAAAIAACABAAAAAoAAAAEAAAARAAAgAYAAAAMAAAAAAAAAAQAAAACAAAAFAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA">
      <br>
      <i>or, choose you're fighter...</i>
      <div style="display: flex; gap: 6px; height: 150px;">
        <!-- template for buttons -->
        <div id="btn-template" style="display: none;"><button onclick="onItemClick(event)" style="display: inline-block; margin-right: 10px;"><img data-src="https://mii-unsecure.ariankordi.net/miis/image.png?shaderType=switch&amp;type=variableiconbody&amp;width=96&amp;texResolution=128&amp;resourceType=low&amp;scale=1&amp;data=" width="128"><div>template</div></button></div>
        <!-- define buttons here -->
        <meta data-name="jasmine" data-data="AwAAQKBBOMSghAAA27iHMb5gKyoqQgAAWS1KAGEAcwBtAGkAbgBlAAAAAAAAABw3EhB7ASFuQxwNZMcYAAgegg0AMEGzW4JtAABvAHMAaQBnAG8AbgBhAGwAAAAAAJA6">
        <meta data-name="soyun" data-data="000f160e146467674d564d551b1f1e1326293037454c565e212e3144070e7279848b908b8fa3aac4d0d7dee5ecf3ff">
        <meta data-name="charline" data-data="AwAFMG0rAiKJRLe1nDWwN5i26X5uuAAAY0FjAGgAYQByAGwAaQBuAGUAAAAAAEwmApBlBttoRBggNEYUgRITYg0AACkAUkhQYwBoAGEAcgBsAGkAbgBlAAAAAAAAAHLb">
        <meta data-name="bro mole high" data-data="0402400431040402020b030a0604060208070906020100140402080200394004010c160213040d0f03020a060d09">
        <details open><summary>ugly only for test</summary>
          <meta data-name="Aiueome" data-data="AwEAMAAAAAAAAAAA2sZrOqTA4fgk3wAAABBBAGkAdQBlAG8AbQBlAAAAAAAAAH9/JwAuCXPOgxfsCIUfDyUY0GUAO0K2oxFSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGUq">
          <meta data-name="Zluuuue" data-data="32037f040d0507060c0003620a08120903000301040500320711096100227f05010818031308080e050300000200">
        </details>
      </div>


      <button type="submit">Load CharModel</button>

      <label><input type="checkbox" id="toggleRotation"> Enable Rotation</label>
      <label><input type="checkbox" id="toggleReinitTextures"> Reinitialize Textures Every Frame (Do Not Enable Please)</label>

    </form>

    <!-- Comment/uncomment this element to enable/disable seeing mask/faceline icons. -->
    <style>#texture-display img { height: 100px; }</style>
    <div id="texture-display" style="overflow-y: scroll; height: 250px"></div>

  </div>
  <!-- end layout -->

  <!-- emscripten module (not modularized) -->
  <!-- async here basically guarantees our script loads before this -->
  <script src="https://debian.local:8445/assets/web%20builds/build-em/ffl-emscripten.js"></script>
  <!-- path to FFL resource file (FFLResHigh.dat, AFLResHigh_2_3.dat, etc.) -->
  <meta itemprop="ffl-resource-fetch-path" content="https://debian.local:8445/assets/web%20builds/FFLResMiddle.dat">

  <!-- three.js 0.137.5 from 2022 -->
  <script src="https://unpkg.com/three@0.137.5/build/three.min.js"></script>
  <!-- Include GLTFLoader, OrbitControls -->
  <!--<script src="https://unpkg.com/three@0.137.5/examples/js/loaders/GLTFLoader.js"></script>-->
  <script src="https://unpkg.com/three@0.137.5/examples/js/controls/OrbitControls.js"></script>

  <script src="struct-fu-mini.js"></script>
  <script src="FFLShaderMaterial.js"></script>
  <!-- Include ffl.js after three.js and FFLShaderMaterial.js. -->
  <script src="ffl.js"></script>

  <!-- for character chooser buttons -->
  <script>

// --------------- Main Entrypoint (Scene & Animation) -----------------

// Global variables for the main scene, renderer, camera, controls, etc.
/** @type {THREE.Scene} */
let scene = null;
/** @type {THREE.WebGLRenderer} */
let renderer = null;
/** @type {THREE.Camera} */
let camera = null;
/** @type {THREE.OrbitControls} */
let controls = null;
/** @type {CharModel} */
let currentCharModel;
let isInitialized = false;
// window.isInitialized = false;
let isAnimating = false;

// Option state
let reinitTexturesEveryFrame = false; // For debugging.

window.scene = scene;

// -------------- initializeScene() --------------
/**
 * Initializes the Three.js scene, renderer, camera, lights, and OrbitControls.
 * Called only the first time the button is clicked.
 */
function initializeScene() {
	// Create scene.
	scene = new THREE.Scene();
	scene.background = new THREE.Color(0xE6E6FA);

	// Create renderer.
	renderer = new THREE.WebGLRenderer({ alpha: true });

	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight - 250);
	document.body.appendChild(renderer.domElement);

	// Create camera.
	camera = new THREE.PerspectiveCamera(15, window.innerWidth / (window.innerHeight - 250), 1, 5000);
	// Note that faceline and mask are close, and
	// often you may run into Z-fighting if you
	// don't set near/far plane with care.
	camera.position.set(0, 50, 500);

	// Set up OrbitControls if it is loaded.
	if (typeof THREE.OrbitControls !== 'undefined') {
		controls = new THREE.OrbitControls(camera, renderer.domElement);
		// Initialize defaults.
		controls.autoRotateSpeed = 8; // Set default rotate speed.
		controls.minDistance = 50;
		controls.maxDistance = 2000;
		controls.target.set(0, 20, 0);
	} else {
		console.warn('THREE.OrbitControls is undefined, continuing without controls.');
	}

	isInitialized = true;
	console.debug('initializeScene: Scene, renderer, camera created.');
}

// -------------- startAnimationLoop() --------------
/**
 * Starts the animation loop (only once). The loop updates the
 * CharModel and updates OrbitControls.
 */
function startAnimationLoop() {
	if (isAnimating) {
		return;
	} // Prevent multiple loops.
	isAnimating = true;
	let blinking = true; // Control if blinking is enabled.
	let lastBlinkTime = Date.now();
	let isBlinking = false;

	function animate() {
		requestAnimationFrame(animate);

		// Update OrbitControls.
		if (controls) {
			controls.update();
		}

		// Reinitialize textures every frame for debugging only.
		if (reinitTexturesEveryFrame) {
			currentCharModel._disposeTextures();
			initCharModelTextures(currentCharModel, renderer);
		}

		// Update blink state.
		if (blinking) {
			// Disable blinking if an exception happens.
			try {
				const now = Date.now();
				if (!isBlinking && now - lastBlinkTime >= 1000) {
					const expr = (Math.random() < 0.25) ? 14 : 5;
					currentCharModel.setExpression(expr);
					isBlinking = true;
					lastBlinkTime = now;
				}
				if (isBlinking && now - lastBlinkTime >= 80) {
					currentCharModel.setExpression(FFLExpression.NORMAL);
					isBlinking = false;
					lastBlinkTime = now;
				}
			} catch (e) {
				blinking = false;
				console.warn('Disabled blinking.');
				throw e;
			}
		}

		renderer.render(scene, camera);
	}
	animate();
}

// ------------ updateCharModelInScene(data, modelDesc) --------------
/**
 * Either creates or updates CharModel and adds it to the scene.
 * @param {Uint8Array|string} data
 * @param {Object|null} [modelDesc=null]
 */
function updateCharModelInScene(data, modelDesc = null) {
	// Decode data.
	if (typeof data === 'string') {
		data = parseHexOrB64ToUint8Array(data);
	}
	// Continue assuming it is Uint8Array.
	// If an existing CharModel exists, update it.
	if (currentCharModel) {
		// Remove current CharModel meshes from the scene.
		currentCharModel.meshes.forEach((mesh) => {
			if (mesh) {
				scene.remove(mesh);
			}
		});
		// Update existing model via updateCharModel method.
		currentCharModel = updateCharModel(currentCharModel, data, renderer);
	} else {
		if (!modelDesc) {
			throw new Error('cannot exclude modelDesc if no model was initialized yet');
		}
		// Create a new CharModel.
		currentCharModel = createCharModel(data, modelDesc, window.FFLShaderMaterial, window.Module);
		// Initialize textures for the new CharModel.
		initCharModelTextures(currentCharModel, renderer);
	}
	// Add CharModel meshes to scene.
	currentCharModel.meshes.forEach((mesh) => {
		if (mesh) {
			scene.add(mesh);
		}
	});
}

// -------------- addTogggleListeners() --------------
/**
 * Adds event listeners to checkbox toggles.
 */
function addTogggleListeners() {
	// Get checkbox elements
	const reinitCheckbox = document.getElementById('toggleReinitTextures');
	const rotationCheckbox = document.getElementById('toggleRotation');

	// Listen for changes to the checkboxes
	reinitCheckbox.addEventListener('change', () => {
		reinitTexturesEveryFrame = reinitCheckbox.checked;
		_noCharModelCleanupDebug = reinitTexturesEveryFrame;
		console.log(`Reinitialize textures every frame: ${reinitCheckbox.checked}`);
	});

	rotationCheckbox.addEventListener('change', () => {
		controls.autoRotate = rotationCheckbox.checked;
		console.log(`Rotation enabled: ${rotationCheckbox.checked}`);
	});
}

// ------------------- Main Application Setup -------------------
document.addEventListener('DOMContentLoaded', async function () {
	// Initialize FFL and TextureManager.
	await initializeFFLWithResource();

	// Set up the toggle checkboxes.
	addTogggleListeners();

	// Assume a form with id "charform" exists in the HTML.
	const form = document.getElementById('charform');
	const defaultTextureResolution = 512; // Typical default.
	// Create an expression flag (for example, using normal, blink, rare expressions).
	const expressionFlag0 = makeExpressionFlag([FFLExpression.NORMAL, 5, 14]);

	form.addEventListener('submit', async function (e) {
		e.preventDefault();

		// Read CharInfo data from the form (Base64-encoded).
		/** @type {HTMLInputElement | null} */
		const charInfoInput = document.querySelector('input#charinfo');
		if (!charInfoInput || !charInfoInput.value) {
			throw new Error('need you to enter something in that there form...');
		}

		// Define the FFLModelDesc.
		const modelDesc = {
			resolution: defaultTextureResolution,
			allExpressionFlag: [expressionFlag0, 0, 0],
			modelFlag: FFLModelFlag.NORMAL,
			resourceType: FFLResourceType.HIGH
		};

		try {
			// First-time scene initialization.
			if (!isInitialized) {
				initializeScene();
			}

			updateCharModelInScene(charInfoInput.value, modelDesc);

			if (_displayFacelineMaskTexture) {
				console.log('bodyScale:', currentCharModel.getBodyScale());
				appendImageFromDataUrl(createCharModelIcon(currentCharModel, renderer));
			}

			// Start the animation loop if not already started.
			if (!isAnimating) {
				startAnimationLoop();
			}

		} catch (err) {
			alert(`Error creating/updating CharModel: ${err}`);
			console.error('Error creating/updating CharModel:', err);
			throw err;Usual
		}
	});
});

document.querySelectorAll('[data-name][data-data]').forEach(el => {
	const clone = document.getElementById('btn-template').cloneNode(true);
	clone.style.display = '';

	const btn = clone.querySelector('button');
	const img = btn.querySelector('img');
	const div = btn.querySelector('div');

	const data = el.getAttribute('data-data-icon') || el.getAttribute('data-data');
	img.setAttribute('src', img.getAttribute('data-src') + encodeURIComponent(data));
	btn.setAttribute('data-data', el.getAttribute('data-data'));
	div.textContent = el.getAttribute('data-name');

	el.replaceWith(clone);
});

const charForm = document.getElementById('charform');
const charInfoInput = document.getElementById('charinfo');
function onItemClick(e) {
	e.preventDefault();
	const data = e.currentTarget.getAttribute('data-data');
	console.log('clicked: ', data);
	//if (!isInitialized) {
		charInfoInput.value = data;
		charform.dispatchEvent(new Event('submit'));
	//} else {
	//  updateCharModelInScene(data);
	//}
}
  </script>
</body>
